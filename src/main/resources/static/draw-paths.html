<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<style>
    body { background-color: grey; }

    .hexagon { fill: white; pointer-events: all; }
    .hexagon path { -webkit-transition: fill 250ms linear; transition: fill 250ms linear; }
    .hexagon :hover { fill: pink; }
    .hexagon .fill { fill: red; }

    .mesh { fill: none; stroke: #000; stroke-opacity: .2; pointer-events: none; }
    .border { fill: none; stroke: #000; stroke-width: 2px; pointer-events: none; }
</style>
<link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/themes/smoothness/jquery-ui.css">
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/sha1.js"></script>

<script>
// geometries is the core object list
// arcs is a secondary data structure required by topojson
function hexTopology(radius, width, height) {
    const dx = radius * 2 * Math.sin(Math.PI / 3);
    const dy = radius * 1.5;
    const m = Math.ceil((height + radius) / dy) + 1;
    const n = Math.ceil(width / dx) + 1;
    const geometries = [];
    const arcs = [];

    for (let j = -1; j <= m; ++j) {
        for (let i = -1; i <= n; ++i) {
            const x = (i + (j & 1) / 2) * 2;
            const y = j * 2;
            const a = [[x, y - 1], [1, 1]];
            const b = [[x + 1, y], [0, 1]];
            const c = [[x + 1, y + 1], [-1, 1]];
            arcs.push(a, b, c);
        }
    }

    for (let j = 0, q = 3; j < m; ++j, q += 6) {
        for (let i = 0; i < n; ++i, q += 3) {
            const p3 = ~(q + (n + 2 - (j & 1)) * 3);
            const p5 = ~(q - (n + 2 + (j & 1)) * 3 + 2);
            // hexagon // fill: Math.random() > i / n * 2
            const xyloc = [i, j];
            geometries.push({ type: "Polygon", xyloc: xyloc, arcs: [[q, q + 1, q + 2, p3, ~(q - 2), p5]], fill: 0 });
        }
    }

    return {
        transform: { translate: [0, 0], scale: [1, 1] },
        objects: { hexagons: { type: "GeometryCollection", geometries: geometries }},
        arcs: arcs
    };
}

function hexProjection(radius) {
    const dx = radius * 2 * Math.sin(Math.PI / 3);
    const dy = radius * 1.5;
    return {
        stream: function(stream) {
            return {
                point: function(x, y) { const sx = x * dx / 2; const sy = (y - (2 - (y & 1)) / 3) * dy / 2; stream.point(sx, sy); },
                lineStart: function() { stream.lineStart(); },
                lineEnd: function() { stream.lineEnd(); },
                polygonStart: function() { stream.polygonStart(); },
                polygonEnd: function() { stream.polygonEnd(); }
            };
        }
    };
}

function main() {
    const width = 960, height = 500, radius = 20;
    const projection = hexProjection(radius);
    const path_fcn = d3.geo.path().projection(projection);

    const topology = hexTopology(radius, width, height);
    const mesh = topojson.mesh(topology, topology.objects.hexagons);

    // const topo_text = JSON.stringify(topology);
    // console.log(topo_text);
    // const topology = JSON.parse(topo_text);

    // const mesh_text = JSON.stringify(mesh);
    // console.log(mesh_text);

    const svg = d3.select("body").append("svg");
    svg.attr("width", width).attr("height", height);

    const grid = svg.append("g").attr("class", "hexagon");
    const paths = grid.selectAll("path")
        .data(topology.objects.hexagons.geometries)
        .enter()
        .append("path");

    paths
        .attr("d", function(d) { const geo = topojson.feature(topology, d); return path_fcn(geo); })
        .attr("class", function(d) { return d.fill ? "fill" : null; })
        .on("mousedown", mousedown)
        .on("mousemove", mousemove)
        .on("mouseup", mouseup);

    svg.append("path").attr("class", "mesh")
        .datum(mesh)
        .attr("d", path_fcn);

    paths.attr("cell_id", function(d, i) { const hash = CryptoJS.SHA1(JSON.stringify(d.arcs)); return hash; });
    paths.attr("cell_index", function(d, i) { return i; });
    paths.attr("xyloc", function(d, i) { return d.xyloc; });

    const border = svg.append("path").attr("class", "border");
    border.call(redraw);

    let mousing = 0;

    function mousedown(d) {
        mousing = d.fill ? -1 : +1;
        mousemove.apply(this, arguments);
    }

    function mousemove(d) {
        if (mousing) {
            d3.select(this).classed("fill", d.fill = mousing > 0);
            border.call(redraw);
        }
    }

    function mouseup() {
        mousemove.apply(this, arguments);
        mousing = 0;
    }

    function redraw(border) {
        const cb = function(a, b) { return a.fill ^ b.fill; };
        const mesh = topojson.mesh(topology, topology.objects.hexagons, cb); // redundant ??
        border.attr("d", path_fcn(mesh));
    }
}

function dump_cells_filtered() {
    const svg = d3.select("svg");
    // const grid = svg.select("g");
    const paths = svg.selectAll("path");

    function replacer(key, value) {
        // if (typeof value === "string") return undefined;
        if (key === "type") return undefined;
        if (key === "arcs") return undefined;
        if (key === "coordinates") return undefined;
        return value;
    }

    const raw_text = JSON.stringify(paths, replacer);
    console.log(raw_text);
}

function dump_cells() {
    const svg = d3.select("svg");
    // const grid = svg.select("g");
    const paths = svg.selectAll("path");

    const items = [];

    paths.each(function() {
        const it = d3.select(this);
        const it_data = it.datum();
        if (!it_data) return;
        const active = it_data.fill;
        if (!active) return;

        const o = {
            // class: this.getAttribute('class'),
            cell_id: this.getAttribute('cell_id'),
            cell_index: this.getAttribute('cell_index'),
            xyloc: this.getAttribute('xyloc'),
            colors: [ active ]
        };
        items.push(o);
    });

    const json_text = JSON.stringify(items);
    console.log(json_text);
}

document.addEventListener("DOMContentLoaded", function(event) {
    console.log("DOM fully loaded and parsed");
    main();
});
</script>
</head>
<body>
<p/>
<input type="button" onclick="dump_cells();" value="dump!" />

<script src="lib/iris.min.js"></script>
pen-color: <input type="text" id="color-picker" value="#bada55" />
<script>
    jQuery(document).ready(function($){
        $("#color-picker").iris({
            mode: 'hsv',
            palettes: true,
            change: function(event, ui) {
                $("#junk").css('color', ui.color.toString());
            }
        })
    });
 
    $(document).click(function (e) {
        if (!$(e.target).is("#color-picker, .iris-picker, .iris-picker-inner")) {
            $('#color-picker').iris('hide');
            return false;
        }
    });
    $('#color-picker').click(function (event) {
        $('#color-picker').iris('hide');
        $(this).iris('show');
        return false;
    });
</script>

</body>
</html>

<!--
<div>
<link rel="stylesheet" href="css/palette-color-picker.css">
<script src="lib/palette-color-picker.min.js"></script>
<script>
    $(document).ready(function(){ $("[name='pen-color']").paletteColorPicker(); });
</script>

pen-color: <input type="text" name="pen-color" data-palette='["#D50000","#304FFE","#00B8D4","#00C853","#FFD600","#FF6D00","#FF1744","#3D5AFE","#00E5FF","#00E676","#FFEA00","#FF9100","#FF5252","#536DFE","#18FFFF","#69F0AE","#FFFF00","#FFAB40"]' value="" style="margin-right:48px;">
</div>
-->

<!--
<form>
<input type="text" id="color" name="color" value="#123456" />
</form>

<script> function color() { alert("color"); } </script>
<form onsubmit="color(); return false"> </form>
-->

<!--
<div id="colorpicker">
<script src="lib/farbtastic.js"></script>
<script type="text/javascript" charset="utf-8">
    $(document).ready(function() { $("#colorpicker").farbtastic("#color"); });
</script>
<script type="text/javascript">
    jQuery.browser = {};
    (function () {
        jQuery.browser.msie = false;
        jQuery.browser.version = 0;
        if (navigator.userAgent.match(/MSIE ([0-9]+)\./)) {
            jQuery.browser.msie = true;
            jQuery.browser.version = RegExp.$1;
        }
    })();
    $(document).ready(function() { $("#colorpicker").farbtastic("#color"); });
</script>
</div>

https://github.com/mattfarina/farbtastic
http://acko.net/blog/farbtastic-jquery-color-picker-plug-in/
-->

<!--
<div>
<input type="button" onclick="color();" value="color" />

https://raw.githubusercontent.com/carloscabo/jquery-palette-color-picker/master/src/
palette-color-picker.min.js
palette-color-picker.css
</div>
-->
<!--
// window.onload, document.onload
// $(document).ready(function(){..}); // jQuery

The onload event is a standard event in the DOM, while the ready event is specific to jQuery. 

The purpose of the ready event is that it should occur as early as possible after the document has loaded, so that code that adds functionality to the elements in the page doesn't have to wait for all content to load.


https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded
-->

<!--
https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js
https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js
https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.css
https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/themes/smoothness/jquery-ui.min.css
-->
